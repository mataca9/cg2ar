<!DOCTYPE html>

<head>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <!-- three.js library -->
    <script src='js/three.min.js'></script>
    <script src='js/keyboard.three.js'></script>
    <script src='js/joystick.js'></script>
    <!-- ar.js -->
    <script src="js/ar.min.js"></script>
    <!-- main -->
    <script src="js/main.js"></script>
    <script>THREEx.ArToolkitContext.baseURL = ''</script>

    <style>
        #power {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            z-index: 100;
            display: block;
            font-family: Arial;
        }

        button {
            position: absolute;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            z-index: 9999;
        }

        #launch {
            bottom: 15px;
            left: 15px;
            background: red;
        }

        #toggler {
            bottom: 100px;
            left: 15px;
            background: green;
        }

        #container {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            padding: 0;
            margin: 0;
            -webkit-user-select: none;
            -moz-user-select: none;
            position: absolute;
            z-index: 10;
        }
    </style>
</head>

<body style='margin : 0px; overflow: hidden; font-family: Monospace;'>
    <div id="container"></div>
    <div id="power">Power: 0%</div>
    <button id="launch"></button>
    <button id="toggler"></button>
    <script>
            //////////////////////////////////////////////////////////////////////////////////
            //		Init
            //////////////////////////////////////////////////////////////////////////////////

            (function () {

                // init renderer
                var renderer = new THREE.WebGLRenderer({
                    antialias: true,
                    alpha: true
                });
                renderer.setClearColor(new THREE.Color('lightgrey'), 0)
                renderer.setSize(640, 480);
                renderer.domElement.style.position = 'absolute'
                renderer.domElement.style.top = '0px'
                renderer.domElement.style.left = '0px'
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap√è
                // VERY IMPORTANT
                renderer.autoClear = false;
                document.body.appendChild(renderer.domElement);


                // array of functions for the rendering loop
                var onRenderFcts = [];

                // init scene and camera
                var scene = new THREE.Scene();
                var sceneMask = new THREE.Scene();

                //Create a PointLight and turn on shadows for the light
                var light = new THREE.PointLight(0xdadada, 1, 100);
                light.position.set(0, 10, 10);
                light.castShadow = true;            // default false
                scene.add(light);

                //Set up shadow properties for the light
                light.shadow.mapSize.width = 512;  // default
                light.shadow.mapSize.height = 512; // default
                light.shadow.camera.near = 0.5;    // default
                light.shadow.camera.far = 500      // default

                // init keyboard
                var keyboard = new THREEx.KeyboardState();

                //////////////////////////////////////////////////////////////////////////////////
                //		Initialize a basic camera
                //////////////////////////////////////////////////////////////////////////////////

                // Create a camera
                var camera = new THREE.Camera();
                scene.add(camera);

                ////////////////////////////////////////////////////////////////////////////////
                //          handle arToolkitSource
                ////////////////////////////////////////////////////////////////////////////////

                var arToolkitSource = new THREEx.ArToolkitSource({
                    // to read from the webcam 
                    //sourceType: 'webcam',

                    // // to read from an image
                    sourceType: 'image',
                    sourceUrl: THREEx.ArToolkitContext.baseURL + '/img/bg6.jpeg',

                    // to read from a video
                    // sourceType : 'video',
                    // sourceUrl : THREEx.ArToolkitContext.baseURL + '../data/videos/headtracking.mp4',		
                })

                arToolkitSource.init(function onReady() {
                    onResize()
                })

                // handle resize
                window.addEventListener('resize', function () {
                    onResize()
                })
                function onResize() {
                    arToolkitSource.onResize()
                    arToolkitSource.copySizeTo(renderer.domElement)
                    if (arToolkitContext.arController !== null) {
                        arToolkitSource.copySizeTo(arToolkitContext.arController.canvas)
                    }
                }
                ////////////////////////////////////////////////////////////////////////////////
                //          initialize arToolkitContext
                ////////////////////////////////////////////////////////////////////////////////


                // create atToolkitContext
                var arToolkitContext = new THREEx.ArToolkitContext({
                    cameraParametersUrl: THREEx.ArToolkitContext.baseURL + 'markers/camera_para.dat',
                    detectionMode: 'mono',
                })
                // initialize it
                arToolkitContext.init(function onCompleted() {
                    // copy projection matrix to camera
                    camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());
                })

                // update artoolkit on every frame
                onRenderFcts.push(function () {
                    if (arToolkitSource.ready === false) return

                    arToolkitContext.update(arToolkitSource.domElement)

                    // update scene.visible if the marker is seen
                    scene.visible = camera.visible
                })

                ////////////////////////////////////////////////////////////////////////////////
                //          Create a ArMarkerControls
                ////////////////////////////////////////////////////////////////////////////////

                // init controls for camera
                var markerControls = new THREEx.ArMarkerControls(arToolkitContext, camera, {
                    type: 'pattern',
                    patternUrl: THREEx.ArToolkitContext.baseURL + 'markers/patt.hiro',
                    changeMatrixMode: 'cameraTransformMatrix'
                })
                // as we do changeMatrixMode: 'cameraTransformMatrix', start with invisible scene
                scene.visible = false

                //////////////////////////////////////////////////////////////////////////////////
                //		add an object in the scene
                //////////////////////////////////////////////////////////////////////////////////

                // add a torus knot

                // Elements

                var element = sphere(scene);
                var field = ground(scene);

                onRenderFcts.push(function (delta) {
                    element.hitTest(field);
                    element.update();

                    if (keyboard.pressed("z")) {
                        element.powerUp();
                    } else {
                        element.release();
                    }
                });

                // Mug

                var element2 = cylinder(sceneMask, 0);

                element2.position.z = 1.5;
                element2.position.x = 1.7;
                element2.opacity = 0.1;

                // -- Arrow
                var dir = new THREE.Vector3(0, 0, 0);

                //normalize the direction vector (convert to vector of length 1)
                dir.normalize();

                var origin = new THREE.Vector3(0, 0, 0);
                var length = 1;
                var hex = 0xff0000;

                var arrowHelper = new THREE.ArrowHelper(dir, origin, length, hex);
                element.add(arrowHelper);

                //////////////////////////////////////////////////////////////////////////////////
                //		render the whole thing on the page
                //////////////////////////////////////////////////////////////////////////////////

                // render the scene
                var mugVisible = false;
                onRenderFcts.push(function () {
                    renderer.clear();

                    renderer.context.colorMask(mugVisible, mugVisible, mugVisible, mugVisible); // R, G, B, A
                    renderer.render(sceneMask, camera);

                    renderer.context.colorMask(true, true, true, true);
                    renderer.render(scene, camera);
                })

                // joystick
                var joystick = new VirtualJoystick({
                    container: document.getElementById('container'),
                    mouseSupport: true,
                });
                joystick.addEventListener('touchStart', function () {
                    console.log('down')
                });
                joystick.addEventListener('touchEnd', function () {
                    console.log('up')
                });

                onRenderFcts.push(function () {
                    element.rotation.z -= joystick.deltaX() / 1000;
                    element.rotation.x += joystick.deltaY() / 1000;
                });

                // run the rendering loop
                var lastTimeMsec = null
                requestAnimationFrame(function animate(nowMsec) {
                    // keep looping
                    requestAnimationFrame(animate);
                    // measure time
                    lastTimeMsec = lastTimeMsec || nowMsec - 1000 / 60
                    var deltaMsec = Math.min(200, nowMsec - lastTimeMsec)
                    lastTimeMsec = nowMsec

                    // call each update function
                    onRenderFcts.forEach(function (onRenderFct) {
                        onRenderFct(deltaMsec / 1000, nowMsec / 1000)
                    });
                });


                // Html event listeners
                var launch = document.getElementById("launch");
                var toggler = document.getElementById("toggler");

                launch.addEventListener("mouseup", LaunchPress, false);
                launch.addEventListener("touchend", LaunchPress, false);

                toggler.addEventListener("mouseup", TogglePress, false);
                toggler.addEventListener("touchend", TogglePress, false);

                function LaunchPress(event) {
                    //handle tap or click.
                    element.maxRelease();
                    event.preventDefault();
                    return false;
                }

                var lastToggle = 0;
                function TogglePress() {
                    if (lastTimeMsec - lastToggle < 1) return false;

                    mugVisible = !mugVisible;       
                    lastToggle = lastTimeMsec;
                    return false;
                }

            })();
    </script>
</body>